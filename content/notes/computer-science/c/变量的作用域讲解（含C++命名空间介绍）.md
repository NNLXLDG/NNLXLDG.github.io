# 变量的作用域讲解

23智能科学实验班-谢许康-302023568034


## 一、C语言变量回顾

不变的值称为**常量**,可变的值称为**变量**

### 1.初始化变量

**类型**是用来创建变量的。
> data_type + name

```c
char ch = 'c'
int weight = 148
int salary = 30000
double price = 33.3
```

### 2.局部变量和全局变量

变量分为局部变量和全局变量  
**{}外面的变量称为全局变量,  {}内部的变量称为局部变量.**  

包括在另一个文件里面的,也算全局变量,但是在使用之前,要声明外部变量,使用`extern+数据类型+名字`来声明变量

```c
int a = 100;
int main()
{
	int a = 10;
	printf("a=%d\n", a);        
	return 0;
}
```
输出结果为10,  
当全局变量与局部变量冲突时,**局部优先**,没有局部,只能全局。应避免局部变量和全局变量取一样的名。

```c
int main()
{
	int num1 = 0;
	int num2 = 0;
	scanf("%d %d", &num1, &num2);
	int sum = num1 + num2;
	printf("%d\n", sum);
    return 0;
}
```
&表示取地址,scanf表示扫描输入

### 3.变量的作用域和生命周期
变量的作用域（scope）是程序设计概念，通常来说，一段程序代码中所有用到的名字并不总是有效/可用的,而限定这个名字的可用性的代码范围就是这个名字的**作用域**.

**局部变量**的作用域  
局部变量的作用域是变量所在的局部范围，大包小

```c
//这是一个错误示范
int main()
{
	{
        int a = 12;
		printf("a=%d\n", a);
	}
	printf("a=%d\n", a);//报错
	return  0;
}
```
局部变量只能在局部生效,第二个`printf("a=%d\n", a)`无法输出。

```c
int main()
{
	int a = 12;
	{
		printf("a=%d\n", a);
	}
	printf("a=%d\n", a);
	return  0;
}

```
两个a都可正常输出,因为`int a = 12;`对外面那个{}以内均适用  

**全局变量**的作用域
全局可用，extern可用于外部，作用域是整个工程

```c
int a = 12;

int main()
{
	{
		printf("a=%d\n", a);
	}
	printf("a=%d\n", a);
   	return  0;
}
```
两个a的值都可以正常输出

演示全局变量的作用域
```c
int a = 10;

void test()
{
	printf("test-->%d\n", a);
}

int main()
{	
	test();
	{
		printf("a=%d\n", a);
	}
	printf("a=%d\n",a);
	return 0;
}

```
三个a的值都可正确输出  
自定义函数中也可使用

声明外部变量
```c
extern int a;
```

**（非静态）局部变量**的生命周期  
进入作用域到出作用域

**全局变量**的生命周期  
整个程序的开始到结束


### 4.全局变量和局部变量在内存中的存储
C语言变量的存储有两种方式：**静态存储方式和动态存储方式**，相应的生产期也有两种：**静态生存期和自动生存期**。

1. 静态存储方式：在程序运行前为变量内存分配内存，在程序结束后回收变量的内存。（静态生存期）
2. 动态存储方式：在程序运行过程中，根据需要动态地分配或回收内存，与静态存储方式相比，动态存储方式，具有更好的存储效率。（自动生存期）

**所有的全局变量都是静态存储方式。**，而局部变量要根据存储类型来区分具体的存储方式。

内存中的三个区域：栈区、堆区、静态区。
1. 自动局部变量（默认）是放在内存的栈区
2. 全局变量和静态变量是放在内存的静态区
3. 堆区是⽤来动态内存管理的

<img src="__IMGPLACEHOLDER__变量在内存中的存储.png__IMGPLACEHOLDER__" alt="Alt text" />

#### 4.1全局变量的存储


#### 4.2局部变量的存储
三种储存类型：**自动变量、静态局部变量、寄存器变量**

##### 4.2.1自动变量

自动变量的定义方式：
```c
auto <数据类型> <变量名>
```
**auto可省略，没有声明储存类型的局部变量，一律默认为自动变量**，平时在函数中看到的没有`auto`修饰的`数据类型名+变量名`都是自动变量。

只有在局部变量的作用域，自动变量才能起作用。在程序进入作用域，编译系统自动为其提供内存；在离开作用域后，回收其内存。

```c
#include <stdio.h>
 
int max(int x,int y)     //主函数调用该函数进行传参时，为x,y分配内存,该过程叫做“形参实例化”，函数调用完成后会自动销毁
{                  
	int z;               //执行至此，为z分配内存
	if(x > y)
		z = x;
	else
		z = y;
	return z;            //执行至此，回收x,y,z的内存
 
}
int main()
{
	int a, b, c;         //执行至此，为a,b,c分配内存
	scanf("%d%d", &a, &b);
	c = max(a,b);        
	printf("max=%d\n",c);//执行至此，回收a,b,c的内存
	return 0;
}
```

分析下面变量的创建销毁过程
```c
#include <stdio.h>
 
int fac(int n)
{
	int f = 10;
	f = f * n;
	return (f);
}
int main()
{
	int s;
	s = fac(2);
	printf("第一次调用的s:%d\n",s);
	s = fac(3);
	printf("第二次调用的s:%d\n",s);
	return 0;
}
```

##### 4.2.2 静态局部变量
定义形式：
```c
static  <数据类型> <变量名>
```

分析下面变量的创建销毁过程
```c
#include <stdio.h>
 
int fac(int n)
{
	static int f = 10;
	f = f * n;
	return (f);
}
int main()
{
	int s;
	s = fac(2);
	printf("第一次调用的s:%d\n",s);
	s = fac(3);
	printf("第二次调用的s:%d\n",s);
	return 0;
}
```

**static修饰局部变量改变了变量的生命周期，生命周期改变的本质是改变了变量的存储类型，本来⼀个局部变量是存储在内存的栈区的，但是被 static 修饰后存储到了静态区。存储在静态区的变量和全局变量是⼀样的，⽣命周期就和程序的⽣命周期⼀样了，只有程序结束，变量才销毁，内存才回收。但是作⽤域不变的。**

生命周期≠作用域（现场解释一下）


##### 4.2.3 寄存器变量
寄存器变量是存储在CPU寄存器的自动变量，便于快速访问。

寄存器变量的定义方式：
```c
register 数据类型 变量名
```

注意：由于寄存器变量存储在CPU的寄存器中，不存储在内存单元中，无法进行取地址运算。


### 5.static和extern
static 和 extern 都是C语⾔中的关键字。    
static 可以  
+ 修饰局部变量
+ 修饰全局变量
+ 修饰函数


**extern 是⽤来声明外部符号的。**  



#### 5.1 static修饰全局变量
代码一：

add.c
```c
int g_val = 2018;
```

test.c
```c
#include <stdio.h>
extern int g_val;
int main()
{
    printf("%d\n", g_val);
    return 0;
}

```

代码二：
add.c
```c
static int g_val = 2018;
```

test.c
```c
#include <stdio.h>
extern int g_val;
int main()
{
    printf("%d\n", g_val);
    return 0;
}
```

extern 是⽤来声明外部符号的，如果⼀个全局的符号在A⽂件中定义的，在B⽂件中想使⽤，就可以使⽤ extern 进⾏声明，然后使⽤。  

代码1正常，代码2在编译的时候会出现链接性错误。


**结论：**  
1. ⼀个全局变量被static修饰，使得这个全局变量只能在本源⽂件内使⽤，不能在其他源⽂件内使⽤。
2. 原因是全局变量默认是具有外部链接属性的，在外部的⽂件中想使⽤，只要适当的声明就可以使⽤；但是全局变量被 static 修饰之后，外部链接属性就变成了内部链接属性，只能在⾃⼰所在的源
⽂件内部使⽤了，其他源⽂件，即使声明了，也是⽆法正常使⽤的。
3. 如果⼀个全局变量，只想在所在的源⽂件内部使⽤，不想被其他⽂件发现，就可以使⽤static修饰。



#### 5.2 static修饰函数
编写大型工程时,往往会把自定义函数放在另外一个源文件中,这样会更加清晰.  

代码1(无static修饰)
```c
//add.c
int Add(int x, int y)
{
    return x+y;
}

//test.c
extern int Add(int x, int y);

int main()
{
    printf("%d\n", Add(2, 3));
    return 0;
}
```

代码2(有static修饰)

```c
//add.c
static int Add(int x, int y)
{
    return x+y;
}
//test.c
extern int Add(int x, int y);

int main()
{
    printf("%d\n", Add(2, 3));
    return 0;
}
```
代码1正常，代码2在编译的时候会出现连接性错误.



## 二、C++解决方法：命名空间-namespace

### 1.为什么需要命名空间
命名空间是ANSI C++引入的可以由用户命名的作用域，用来处理程序中常见的同名冲突。  

在c++中有4层次的作用域：**文件、函数、类、复合语句**。在不同的作用域中可以定义名字相同的变量，互不干扰，便于系统区别他们。  

如下：
```cpp
class A
{
public:
    void fun1();
private:
    int i;
};

void A::fun1()
{

}

class B
{
public:
    void fun1();
private:
    int i;
};

void B::fun1()
{

}
```
这样，他们就不会发生混淆。  

但是，一个大型的应用软件，往往不是由一个人独立完成的，而是由若干不同的人合作完成的，不同的人分别完成不同的部分，最后组成一个完整的程序。假如不同的人分别定义了类，放在了不同的文件中，在主函数的文件中需要使用这些类时，就用#include指令将这些头文件包含进来。由于头文件是由不同的人设计的，有可能在不同头文件中用了相同的名字来命名所定义的类或函数。这样，程序中就会出现名字冲突。  

以下面的程序为例，在People A.h和People B.h分别定义类和函数：
```cpp
//PeopleA.h
class Student
{
public:
    Student(int n, char s, string name)
    {
        //.....
    }
private:
    int num;
    string name;
    char sex;
};
int fun(int a, int b)
{
    return a + b;
}

//PeopleB.h
class Student
{
public:
    Student(int n, char s, string name)
    {
        //.....
    }
private:
    int num;
    char sex;
    string name;
};
int fun(int a, int b)
{
    return a + b;
}
```
假如在主程序中要用到People A.h中的Student函数，需要在头文件中包含People A.h，同时要用到People B.h中的Student函数，需要在头文件中包含People B.h，如果主程序如下：
```cpp
#include <iostream>
#include "People A.h"
#include "People B.h"
int main()
{
    Student stdu1(101, 18, "wang");
    cout << fun(5, 3) << endl;
    return 0;
}
```
这时程序就会出错，因为在预编译后，头文件中的 内容取代了对应的#include指令，这样就在同一个程序文件中出现了两个Student类和两个fun函数，显然是重复定义，这就是名字冲突，即在同一个作用域中有两个或者多个同名的实体。


### 2. 什么是命名空间
所谓命名空间，实际上就是一个由程序设计者命名的内存区域。程序设计者可以根据需要制定一些有名字的空间域，把一些全局实体分别放在各个命名空间中，从而与其他全局实体分隔开来。如：
```cpp
namespace AA
{
    int a;
    double b;
}
```
namespace是定义命名空间锁必须写的关键字，AA是自己制定的命名空间的名字。如果在程序中要使用a和b，必须加上命名空间名和作用域分辨符`::`，如`AA::a`，`AA::b`，这种用法称为命名空间限定。

命名空间的作用是建立一些互相分隔的作用域，把一些全局实体分隔开来，以免产生名字冲突。


### 3. 使用命名空间解决名字冲突
如下程序为例：
```cpp
//PeopleA.h
namespace PeopleA
class Student
{
public:
    Student(int n, char s, string name)
    {
        //.....
    }
private:
    int num;
    string name;
    char sex;
};
int fun(int a, int b)
{
    return a + b;
}

//PeopleB.h
namespace PeopleB
class Student
{
public:
    Student(int n, char s, string name)
    {
        //.....
    }
private:
    int num;
    char sex;
    string name;
};
int fun(int a, int b)
{
    return a + b;
}

#include <iostream>
#include "People A.h"
#include "People B.h"
int main()
{
    PeopleA::Student stdu1(101, 18, "wang");
    cout << PeopleA::fun(5, 3) << endl;
    PeopleB::Student stdu1(101, 18, "wang");
    cout << PeopleB::fun(5, 3) << endl;
    return 0;
}
```

### 4.使用命名空间成员的方法
在引用命名空间成员时，要用命名空间名和作用域分辨符对命名空间成员进行限定，以区别不同的命名空间中的同名标识符。

即：命名空间名::命名空间成员名  

c++提供了一些机制，能简化使用命名空间的使用：
1. 使用命名空间别名
```
可以为命名空间起一个别名，用来替代较长的命名空间名，如：
namespace PeopleA
可以用一个较短的别名替代它。如：
namespace PA = PeopleA
```
2. 使用using命名空间成员名
```
using后面的命名空间成员名必须是由命名空间限定的名字，如：
using AA::i；
```
3. 使用using namespace命名空间名
```
如：using namespace AA;
声明了在本作用域中要用到命名空间AA中的成员，在使用该命名空间的任何成员时都不必再使用命名空间限定。
```

### 5.无名的命名空间
c++中可以声明无名的命名空间，如：

```
namespace 
{
    void fun()
    {
        //....
    }
}
```

由于命名空间没有名字，在其他文件中显然无法引用，它只在本文件的作用域有效。若无名命名空间的成员fun函数的作用域为文件A，在文件A中使用无名命名空间的成员，不用也无法用命名空间名限定。

### 6.标准命名空间std

标准C++库中的所有标识符都是在一个名为std的命名空间中定义的，或者说标准头文件中的函数、类、对象和模板实在命名空间std中定义的。一般用using namespace语句对命名空间std进行声明，这样可以不必对每个命名空间成员一一进行处理，在文件的开头加入如下语句：  
```cpp
using namespace std;
```
这样，在std中定义和声明的所有标识符在本文件中都可以作为全局变量来使用。


### 总结
由于namespace的概念，使用C＋＋标准程序库的任何标识符时，可以有三种选择：

1. 直接指定标识符。例如std::ostream而不是ostream。  
完整语句如下  
```cpp
std::cout << std::hex << 3.4 << std::endl;
```
2. 使用using关键字。
```cpp
using std::cout;
using std::endl;
//以上程序可以写成
cout << std::hex << 3.4 << endl;
```
3. 最方便的就是使用using namespace std;
```cpp
#include <iostream>
#include <sstream>
#include <string>
using namespace std;
cout << hex << 3.4 << endl;
```

## 三、作用域与可见性


### 1.总概述
在所有的计算机程序中，一个基本的目标是操作一些数据，然后获得一些结果。为了操作这些数据，需要为这些数据分配一段内存，我们可以将这段内存称为变量。为了方便操作，以及程序可读性方面的考虑，需要使用一个有意义的名称来引用这段内存，这个名称就是变量名。

将名称和一段内存关联起来的工作可以分成两个阶段来进行，分别是变量的声明和定义。在变量声明的时候，只是引入了一个名称，该名称并没有和一段特定的内存关联。也就是说，在声明变量的时候，只是引入了一个助记符，并没有执行内存分配。在定义变量的时候，将前面声明过程中引入的名称关联到了一段特定的内存，内存的大小由变量的类型决定。也就是说，在定义变量的时候，真正执行了内存分配。在有的情况下，变量的声明和定义是需要分开进行的，如：全局变量的声明和定义，可以在多个文件中使用该变量；而在某些情况下，使用一个语句就可以完成变量的声明和定义，如：局部变量的声明和定义。只需要在一个文件中使用该变量。

在C++程序中，当声明并定义了一个变量以后，需要关注如下两个问题：
1. 由声明引入的变量名可以用在什么地方，如何进行名字解析；
2. 由定义分配的内存的生命周期是多少。

为了解决这两个问题，就需要引入**作用域**的概念。作用域是C++程序中的一段区域，一般用正反两个花括号来界定它的范围。**在同一个作用域范围内，一个名称只能唯一关联到一个实体，这个实体可以是变量，函数，类型，模版等。**也就是说，在同一作用域范围内，不同的实体必须对应不同的名称，绝对不允许出现两个不同的实体对应同一个相同的名称的情况。一个名称可以和不同作用域中的不同实体相对应。也就是说，对于同一个名称，在不同的作用域中可以重复使用。

在本文的后续部分，将对各种类型的作用域进行描述，并且介绍在作用域中进行名字解析的规则。

### 2.作用域的分类


#### 2.1概述
我们可以将整个C++程序（在程序中包括各种类型，函数，模版，变量等，并且分布在很多个*.cpp文件中）看成一个很大的整体区域。为了方便对C++程序中已经定义的各种类型，函数，模版，变量的管理，可以把这片大的区域划分成一片片小的命名区段。然后根据各个类型，函数，模版，变量的功能以及用途等，再把这些类型，函数，模版，变量等分别放置在不同的区段中。这些小的区段叫做作用域，C++程序支持四种形式的作用域，分别是：**名字空间作用域，类域，局部作用域，语句作用域。**

名字空间作用域就是程序员利用名字空间定义在C++程序中划分出来的一块比较大的程序区段。在该程序区段内部，可以定义类型，函数，模版，变量。名字空间作用域可以跨越多个*.cpp文件而存在。在名字空间作用域内部还可以继续定义其他的名字空间作用域，也就是说，**名字空间作用域是可以互相嵌套的。**

全局作用域是C++程序最外层的名字空间作用域，也是最大的名字空间作用域。**全局作用域天然存在于C++程序中，它不需要由程序员人为地定义。在全局作用域内部，可以包含其他的，由程序员定义的名字空间作用域，以及没有包含在其他名字空间作用域中的类型，函数，模版，变量。**在全局作用域中定义的变量是全局变量，在全局作用域中定义的函数是全局函数。

在C++程序中，每定义一个类就会引入一个类域。类体所包含的范围就是类域的范围，在类中定义的所有成员都属于该类域。类域位于名字空间作用域内部，该名字空间作用域可能是全局作用域，也可能是用户定义的名字空间作用域。

**每一个函数体内部都是一个局部作用域。该作用域起始于函数体的左花括号“｛”，结束于函数体的右花括号“｝”。**每一个函数都有一个独立的局部作用域。在局部作用域内定义的变量都是局部变量。

在C++程序中，当要求使用单个语句，但程序逻辑却需要不止一个单个语句的时候，我们可以使用复合语句。复合语句通常被称为块，是用花括号括起来的一些单个语句的集合。在复合语句花括号内部的区段也属于局部作用域。

有些语句存在控制结构，并且允许在控制结构中定义变量。如：
```cpp
//示例一：
for ( int K = 0; K < 100;K++ )
  cout << K;     //该行语句属于语句作用域范围，K仅在这一行有效。

//示例二：
for (int K = 0; K < 100;K++)
{
   … //其他代码
   Cout << k;   //花括号内部是复合语句，都属于语句作用域。K在整个花括号内有效。
   … //其他代码
}
```
从控制语句的开始到控制语句结束这一段区域被称为语句作用域。在该控制结构中定义的变量，仅在该语句作用域内有效。如：示例二中，K在花括号内有效，或者示例一中，仅在语句“cout << K;”中有效。语句作用域是最小的作用域。

#### 2.2名字空间作用域

##### 2.2.1名字空间的意义

使用名字空间可以在一定程度上解决命名冲突的问题。假设没有名字空间，那么在C++程序中，所有的实体，如：函数，类型，变量，模版等，都必须被放置在全局域中作为全局实体而出现。在全局域中，这些实体必须具有唯一的名称，不允许存在多个实体同名的情况。因此，当在全局域中引入一些第三方开发的类库的时候，必须要保证第三方类库中命名的实体与全局域中命名的实体在命名方面不冲突。但是，这是很难保证的。为了解决这个问题，就引入了名字空间的概念。

第三方开发方在开发类库的时候，可以首先声明一个名字空间，每一个用户声明的名称空间都代表一个不同的名字空间域。在该名字空间中，可以包含嵌套其他的名称空间，以及函数，类型，变量，模版等的声明和定义。在该名称空间内部声明的实体被称为**名称空间成员**。用户在名字空间中声明的每个实体的名字必须是唯一的，不允许重名。因为在不同用户声明的名字空间中引入了不同的域，所以在这些由不同用户声明的名字空间中可以使用相同的名称。通过这种方式解决了命名冲突的问题。

**在使用名字空间中的成员的时候，名字空间成员的名字会自动与该名字空间重合，或者说被其限定修饰。如：在名字空间A中声明的类B，它的名字是：A::B。**


##### 2.2.2名字空间的定义

用户声明的名字空间以namespace关键字开头，后面是名字空间的名称。名字空间的范围以花括号界定，具体的格式如下：

```cpp
namespace mySpace //mySpace是名字空间的名称
{
   Class myClass { … }; //类定义
   Int myFunction(int para1,int para2); //函数的声明
   Extern double myVar; //变量的声明
}
```
在上面的示例中，声明了一个名称为mySpace的名字空间，该名字空间的作用域由花括号界定，在花括号内部的部分都属于该名字空间的作用域。在该名字空间中，定义了一个类：myClass，声明了一个函数：myFunction，以及一个变量myVar。它们都是该名字空间的成员。

用户声明的名字空间可以位于全局作用域中，也可以位于其他的名字空间的作用域中。在当前的作用域中，名字空间的名称是唯一的，不能与其类型的实体重名。

**在同一个作用域中，可以多次声明相同名称的名字空间。**在这种情况下，将会实现名字空间的累加。比如，A.h头文件和A.cpp源文件都位于全局作用域中，在这两个文件中分别声明如下的名字空间：
```cpp
//A． h文件的代码实现：

namespace mySpace //在这里实现了函数和变量的声明，属于接口部分。

{
   Int AddData (int para1,int para2); //函数的声明

   Extern double myVar;  //变量的声明

}

//B.cpp文件的代码实现：

Include “A.h”
namespace mySpace // 在这里实现了函数和变量的定义，属于实现部分。
{
   Int AddData(int Para1,int Para2) //函数的定义
   {
      Return Para1+Para2;
   }
    Double myVar = 3.14;  //变量的定义，并初始化。
}
```
在这里，存在这样一个规则：在同一个作用域中，如果新声明的一个名字空间的名称与前面声明过的名字空间的名称同名，那么这个后声明的名字空间就是前面声明的名字空间的累加，这两部分内容属于同一个名字空间；如果新声明的这个名字空间不与当前作用域中任何名字空间同名，那么就会定义一个新的名字空间。

在上面的示例中，A.h和A.cpp文件位于全局作用域中。在全局作用域中，两次声明的名字空间具有相同的名称：mySpace。因此，认为这两次声明的名字空间属于同一个名字空间。

通过对上面所描述的规则的使用，在程序设计的时候，可以根据需要，将名字空间的声明拆分成若干个部分来实现，只要这几个部分的声明都在同一个作用域中即可。这个规则的一个典型应用就是：实现接口和具体实现的分离。

在上面的示例中，我们将函数AddData和变量myVar的声明放在了A.h头文件中，而将它们的定义放在了另外一个A.cpp的源文件中。 A.h头文件实现的是函数库的接口的，而A.cpp文件中的内容则是针对接口的实现。因此，在程序设计和开发的时候，这两部分内容可以分别由不同的人在不同的时间实现。通过这种方式，实现了接口和具体实现分离的原则。


##### 2.2.3名字空间成员的定义
当定义了名字空间以后，就可以想名字空间中添加成员。这些被添加的成员可以是：**类型，函数，变量，模版**等。可以通过两种方式向名字空间中添加成员。

1. 第一种方式是：在定义名字空间的同时，在名字空间的花括号内直接完成名字空间成员的定义。也就是说，无论名字空间的定义是采用累加的形式，还是该名字空间分布在多个物理文件中，名字空间成员的声明和定义都在名字空间内部进行。具体示例如下：
```cpp
//方式一：在名字空间中直接完成成员的定义。成员的定义不在划分为声明和定义两部分。
Namespace mySpace
{
   Double myVar = 3.14;
   Int myFunction(int Para1)
   {
       Return Para1*10;
   }
}

//方式二：在名字空间中先完成成员的声明，然后采用名字空间累加的方式，在其他部分完成成员的定义。这个“其他部分”，可以是其他的物理文件，也可以是同一个物理文件。

Namespace mySpace
{
    Extern double myVar;
    Int myFunction(int Para1);
}

Namespace mySpace
{
    Double myVar = 3.14;
    Int myFunction(int Para1)
    {
       Return Para1*10;
    }
}
```
在上面的代码中，在定义了名字空间的同时（无论是采用累加方式，还是一次性完成），在名字空间内部完成了函数myFunction和变量myVar的定义。名字空间的定义和名字空间成员的定义同步完成。

2. 第二种方式是：在定义名字空间的时候，仅仅在名字空间中完成对名字空间成员的声明，而名字空间成员的定义在名字空间之外被实现。具体代码如下：

```cpp
//首先在一个文件中完成名字空间的定义，以及名字空间成员的声明。一般情况下，该文件为头文件（A.h）。
Namespace mySpace
{
    Class myClass {….}；//声明一个类型
    myClass myFunction(myClass Para1);//声明一个函数，该函数返回myClass类型，并以myClass类型为参数。
}
```

在上面的代码中，完成了对名字空间mySpace的定义，同时在名字空间内部，完成了类myClass的定义，以及对函数myFunction的声明。接下来需要在其他地方，名字空间以外，完成对名字空间成员myFunction函数的定义。具体代码如下：

```cpp
//实现函数myFunction定义的位置，可以是另外一个文件，一般为cpp文件，但是也可以在原来的头文件中（一般不会这么干）。
#include “A.h”
mySpace::myClass mySpace::myFunction(myClass Para1)
{
    //下面完成函数的具体实现。
   …
}
```
在上面的代码中，我们可以看到两处差异。一处是函数的返回值类型，myClass被名字空间mySpace限定修饰了；而在函数的参数类型处，myClass直接使用，没有被名字空间mySpace限定修饰。

这里存在这样一个规则：在函数的限定修饰名称“mySpace::myFunction”之后，直到方括号结束的区域都属于mySpace名字空间的作用域范围。也就是上面代码中的红色部分。

也就是说名字空间的作用域可能会有两部分组成，在大多数情况下，名字空间的作用域是由定义名字空间的时候，名字空间体的花括号界定的。但是，当在名字空间之外定义名称空间的成员的时候，在名字空间成员的限定修饰名之后直到结束花括号`（” }”）`，或者分号（;）的部分都属于该名字空间作用域范围。

因此，在上面的代码中，参数的类型不需要被限定修饰，因为那个区域是属于名字空间作用域内的；而函数的返回类型必须要被限定修饰，因为那个区域不属于名字空间的作用域内。

另外还需要注意，在名字空间之外实现名字空间成员的定义的时候，要有一个前提，**那就是：名字空间成员的声明必须在名字空间之内实现。**


##### 2.2.4名字空间成员的使用

在C++程序中，使用名字空间的方式封装一些函数库或者类库的时候，一般情况下，通常的做法是这样的：**首先在一个头文件中定义一个名字空间，然后在该名字空间的定义中声明所有的名字空间成员，如：函数，类型，变量等。**之后将这个头文件引入到一个cpp文件中，并且在这个cpp文件中实现所有名字空间成员的定义。具体示例如下：
```cpp
-----------------A.h------------------------------//头文件名称
namespace myCPlusPlusFunctionsV1.0
{
     Class myClass { …//类成员的声明 }; //定义一个类型
     Extern double myVar; //声明变量
     Void DealClass(myClass*); //声明函数
}
-----------------A.cpp--------------------------//源文件

#include “A.h”

Namespace myCPlusPlusFunctionsV1.0
{
	myClass:: myClass() { … // myClass构造函数的实现}
	…
	//其他myClass类成员的定义。
	…
	double myVar = 3.14;//变量的定义
	void DealClass(myClass*pClass)
	{
  		…//函数的具体实现。
	}
}
```
在使用这些函数库或者类库的时候，首先需要将这个定义了该名字空间的头文件引入，然后开始使用该名字空间中的一些成员。在使用名字空间成员的时候，有三种方式：

1. 第一种方式：域操作符方式。通过域操作符加名字空间名称的方式对名字空间成员名进行限定修饰。具体代码如下：
```cpp


------------------otherCPlusPlusFile.cpp-------------------------

#include “A.h”
Void main()
{
   myCPlusPlusFunctionsV1.0::myClass *pClass = new myCPlusPlusFunctionsV1.0::myClass;
   myCPlusPlusFunctionsV1.01::DealClass(pClass);
}
```

在上面的代码中，“::”是域操作符。名字空间成员的声明被隐藏在名字空间之中，所以，名称空间的成员名称不会与当前作用域中的对象实体名称产生冲突。在使用名字空间成员的时候，可以使用名字空间名+域操作符+名字空间成员名称的方式将名字空间成员引入到当前的作用域中。否则，在当前作用域中，编译器不会找到名字空间的成员。

域操作符也可以被用来引用全局作用域的成员。因为全局作用域没有名称，所以使用如下的符号：
```cpp
::member_name
```

指向全局名字空间的成员。当全局名字空间成员的名称被局部作用域中的名字隐藏的时候，但又需要在局部作用域中使用全局成员的时候，就可以使用这种引用方式。

在上面的示例中，名字空间的名称“myCPlusPlusFunctionsV1.0”比较长，在使用的时候，可能会不方便，因此，C++在处理这个问题的时候，引入了**名字空间别名**的概念。


所谓**名字空间别名**就是为已经定义的名字空间取一个其他的、替代性的名称，一帮情况下，这个名称是简短的，容易记忆的。具体使用方式如下：
```cpp
 
------------------otherCPlusPlusFile.cpp-------------------------
#include “A.h”
Namespace myC++ = myCPlusPlusFunctionsV1.0;
Void main()
{
   myC++::myClass *pClass = new myC++::myClass;
   myC++::DealClass(pClass);
}
```
在上面的代码中，为名字空间“myCPlusPlusFunctionsV1.0”定义了一个别名“myC++”。之后在引用该名字空间成员的时候，就可以使用该别名。

定义名字空间别名的格式是：**以关键字namespace开头，后跟名字空间的别名，并且等于前面定义好的名字空间的名称。**

2. 第二种方式：使用using 声明，一次引入一个名字空间成员。

Using 声明的作用是：使一个名字空间成员在当前作用域中可见，可见的范围是从using声明的语句开始，直到当前作用域结束。如果在using声明语句之后，在当前作用域中又嵌套了其他的作用域，那么using声明在当前作用域中的嵌套作用域中也同样有效。

Using声明以关键字`using`开头，后跟名字空间的成员名称。该成员名称必须是名字空间名称+域操作符+名字空间成员名称形式的限定修饰名称。具体代码如下：
```cpp
//名字空间的定义
Namespace mySpace
{
	Int myFunction(int Para)//在名字空间中定义了一个函数
	{
     	Return Para*10;
	}
}
//在全局作用域中使用using声明，将名字空间成员名引入当前作用域。
Using mySpace::myFunction;
//开始使用名字空间的成员
Void main()
{
   //也可以在此位置使用using声明，即在局部作用域使用using声明。
   myFunction(10);//使用名字空间的成员。因为使用了using声明，所以不需要使用限定修饰的形式。名称myFunction从using声明开始，直到当前作用域结束。
}
```
在上面的代码中，首先定义了一个名字空间，并在名字空间中定义了一个函数。然后在全局作用域中使用了using声明。之后，在main函数中使用名字空间的成员函数myFucntin。

**可以在全局作用域，名字空间作用域，局部作用域中使用using声明。**在使用了using 声明以后，一次只能从源名字空间向当前作用域中引入一个名字空间成员，但可以多次使用using声明。如果该名字空间成员是函数，并且在该名字空间中具有多个重载，那么在使用using声明的时候，所有的重载函数都会被引入到当前的作用域中。**被引入的名字空间成员名只在当前作用域中有效，并且名称唯一。这个被引入的名字空间成员名会隐藏当前作用域外围作用域中的同名名称，也会被当前作用域的嵌套作用域中的同名名称隐藏。**具体情况见如下代码：

```cpp
namespace mySpace
{
   Int myIntVar = 10;//定义一个整型变量。名字空间成员。
}

Int myIntVar = 100;//全局变量
Int main()
{
	Using mySpace::myIntVar;//该using声明隐藏了全局变量myIntVar。
	Int k = 10;
	K = k + myIntVar;//使用的是名字空间的成员变量，所以k的值等于20.
	K = K + ::myIntVar;//这里使用的是全局变量，所以k的值等于110.
	{
     	Int myIntVar = 50;//在此语句作用域中声明的变量隐藏了前面using声明中引入的变量。
    	Int a  = myIntVar ;//a = 50
    	Int b  = ::myIntVar;//b = 100;
   	 	Int C  = mySpace::myIntVar;//c = 10;
	}
}
```
使用using声明将名字空间的成员引入到当前作用域的时候，除了重载函数以外，被引入的成员名称不能与当前作用域中定义的对象实体重名，否则会引起错误。


3. 第三种方式：使用using 指示符，一次引入所有名字空间成员。

Using指示符以关键字using 开头后跟关键字namespace，最后是名字空间的名称。该名字空间的名称必须在前面已经定义。其作用域从using指示符开始，直到当前作用域结束。使用using指示符以后，将会把名字空间中的所有成员引入到当前作用域。具体的代码如下：

```cpp
//定义名字空间
Namespace mySpace
{
	Int myFunction(int Para)
	{
   		Return Para*10;
	}
	Int myVar = 100;
}

//使用using指示符，将名字空间的所有成员引入到当前作用域。目前是全局作用域。
Using namespace mySpace;
Void main()
{
	Int k = myVar + 10;//使用using指示符以后，可以直接使用名字空间中的成员，就好像该//名字空间的成员在当前作用域中定义的一样，不需要限定修饰。
	myFunction(k);
}
```
在上面的代码中，首先定义了一个名字空间mySpace，同时在名字空间中定义了一个函数myFunction，以及一个变量myVar。然后使用using指示符将该名字空间中的成员引入到了全局作用域中。之后，在main函数中使用名字空间的成员，使用的时候，不需要限定修饰，就好像使用当前名字空间中定义的成员一样。

在当前作用域使用using指示符以后，被引用的名字空间将与当前的作用域合并，名字空间中的成员就好像在当前作用域被定义一样。因此，在当前作用域中，不能定义与名称空间成员重名的对象。否则会因此错误。

##### 2.2.5标准名字空间std
在名字空间的概念被提出之前，在C++中就已经存在了大量的库函数。这些库函数有的是标注C形式的，也有的是标准C++形式的。在声明这些库函数的时候，按照其功能和类别，它们被划分到很多不同的头文件中，如：`iostream.h`，`complox.h`，`stdio.h`。当名字空间的概念被提出之后，这些库函数被重新整理，将它们的声明和定义放到了名称空间名称为std的名称空间中。它们被称为标准C++库。

但是为了向前兼容以前实现的C++程序，在对这些库函数进行整理的时候，创建了新的头文件，并采用了新的命名规则，以区分原有的库函数。具体的处理方式描述如下：

对于支持C++的头文件，如：<iostream.h>，在被重新整理之后，它的名称为去掉了头文件的扩展名。新的头文件所包含的功能与旧头文件基本相同，但是它们在std名字空间中；
对于支持C标准的头文件，如：<stdio.h>，在被重新整理之后，它的名称为，在名称的前面加上了前缀字符“C”，并去掉扩展名。新的头文件所包含的功能与旧的头文件基本相同，但是它们在std名字空间中。
原有旧的C++标准头文件，如<iostream.h>，依然被支持，它们不在名字空间std中；
原有旧的C标准头文件，如<stdio.h>，依然被支持，它们不在名字空间std中。


##### 2.2.6名字空间的嵌套
在用户声明的名字空间中还可以继续嵌套其他的名字空间，通过这种分层次的名字空间的结构可以改善函数库的代码组织结构。具体代码如下：

```cpp
Namespace myFirstSpace
{
    Int myVar = 10;
    Namespace mySecondSpace
    {
       int dlVar = 314;
       Int myVar = 100;//它会隐藏外围名字空间声明的变量。
    }
}
```
只要需要，名字空间的嵌套可以一直向下持续下去。在名字空间嵌套的时候，外围名字空间声明的变量可能会被里面嵌套的名字空间声明的同名变量隐藏。在使用嵌套名字空间成员的时候，有三种方式，具体情况如下：

```cpp
//第一种形式：限定修饰名称形式
Int a = MyFirstSpace::mySecondSpace::dlVar;
//第二中形式：using声明的形式：
Using myFirstSpace::mySecondSpace::dlVar;
Int a= dlVar;
//第三中形式：using指示符形式：
Using namespace myFirstSpace::mySecondSpace;
Int a = dlVar;
```


##### 2.2.7未命名名字空间
使用未命名的名字空间，可以定义文件作用域。具有文件作用域的名字空间只在定义它的文件中有效，在其他文件中访问不到该作用域。

未命名名字空间的定义格式如下：
```cpp
----------------------------A.cpp--------------------------
Namespace
{
   Int a = 10;
   Void myFunction(int Para)
}
//使用未命名名字空间中的成员
Void main()
{
   myFunciton(a);//直接使用，不需要限定修饰。
}
```
在使用未命名名字空间中的成员的时候，可以直接使用，不需要限定修饰。未命名名字空间中的成员只能在定义它的文件中使用，在其他文件中是无法访问的。

注意点:
1. 在同一作用域内的**对象名,函数名,枚举常量**会隐藏同名的类名或枚举类型名.
2. 重载的函数可以有相同的函数名.